import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Id } from "./_generated/dataModel";
import { FileCategorySchema, FileItem } from "./helpers";

/* 
    **Uploading files via upload URLs**

    Arbitrarily large files can be uploaded directly to your backend using a generated upload URL. This requires the client to make 3 requests:

    1. Generate an upload URL using a mutation that calls storage.generateUploadUrl().
    2. Send a POST request with the file contents to the upload URL and receive a storage ID.
    3. Save the storage ID into your data model via another mutation.
    
    In the first mutation that generates the upload URL you can control who can upload files to your Convex storage. 
*/



// 1. Generating an upload URL
export const generateUploadUrl = mutation(async (ctx) => {
    // An upload URL can be generated by the storage.generateUploadUrl function of the MutationCtx object:
    return await ctx.storage.generateUploadUrl();
    // This mutation can control who is allowed to upload files.
    // The upload URL expires in 1 hour and so should be fetched shortly before the upload is made.
  });

// 3. Writing the new storage ID to the database  
export const createFileLink = mutation({
    args: {
        name: v.string(),
        category: FileCategorySchema,
        storageId: v.id("_storage"),
    },
    handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (identity === null) {
          throw new Error("Called getCurrentUser without authentication present");
        }
          // Check if we've already stored this identity before.
        const user = await ctx.db
        .query("User")
        .withIndex("idx_token", (q) =>
            q.eq("tokenIdentifier", identity.tokenIdentifier),
        )
        .unique();
        // The file size is not limited, but upload POST request has a 2 minute timeout.
        await ctx.db.insert("File", {
            name: args.name,
            category: args.category,
            storageId: args.storageId,
            uploadedBy: user?._id
        });
    },
});

  export const getResumeByUserId = query({
    args: {
        userId: v.id("User")
    },
    handler: async (ctx, args) => {
        const file = await ctx.db
        .query("File")
        .withIndex("idx_uploadedBy", (q) => q.eq("uploadedBy", args.userId))
        .filter((q) => q.eq(q.field("category"), "Resume"))
        .unique();

        const [user, url] =  await Promise.all([
            await ctx.db.get(file?.uploadedBy as Id<"User">),
            (file?.storageId === undefined ?
                null : await ctx.storage.getUrl(file.storageId)
            )
        ]);

        return {
            file,
            user,
            url
        } as FileItem;

    },
  });

  export const getFileByName = query({
    args: {
        fileName: v.string()
    },
    handler: async (ctx, args) => {
        const file = await ctx.db
        .query("File")
        .withIndex("idx_file_name", (q) => q.eq("name", args.fileName))
        .unique();

        const [user, url] =  await Promise.all([
            await ctx.db.get(file?.uploadedBy as Id<"User">),
            (file?.storageId === undefined ?
                null : await ctx.storage.getUrl(file.storageId)
            )
        ]);

        return {
            file,
            user,
            url
        } as FileItem;
    },
  });

  export const getFiles = query({
    handler: async (ctx) => {
        const files = await ctx.db
        .query("File")
        .withIndex("by_creation_time")
        .order("desc")
        .collect();

        return Promise.all(
            files.map(async (file) => {
                const user = await ctx.db.get(file.uploadedBy as Id<"User">);
                const url = (file?.storageId === undefined
                    ? null 
                    : await ctx.storage.getUrl(file.storageId)
                );
                return {
                    file,
                    user,
                    url
                } as FileItem;
              }),            
        );
    },
  });

  export const getFilesByCurrentUser = query({
    handler: async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
            throw new Error("Unauthenticated call to getOccupationsForCurrentUser");
        }

        const user = await ctx.db
        .query("User")
        .withIndex("idx_token", (q) =>
            q.eq("tokenIdentifier", identity.tokenIdentifier),
        )
        .unique();
        
        const files = user
        ? await ctx.db
            .query("File")
            .withIndex("idx_uploadedBy", (q) =>
                q.eq("uploadedBy", user?._id),
            )
            .collect()
        : undefined;

        return Promise.all(
            (files ?? []).map(async (file) => {
                const user = await ctx.db.get(file.uploadedBy as Id<"User">);
                const url = (file?.storageId === undefined
                    ? null 
                    : await ctx.storage.getUrl(file.storageId)
                );
                return {
                    file,
                    user,
                    url
                } as FileItem;
              }),            
        );
    },
  });

